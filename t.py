import math

from pyspark import SparkConf, SparkContext
from pyspark.shell import sqlContext
from pyspark.sql import SQLContext, functions as sqlfunctions, types

from graphframes import GraphFrame
from graphframes.lib import AggregateMessages as AM
# Import subpackage examples here explicitly so that this module can be
# run directly with spark-submit.

__all__ = ['BeliefPropagation']


localVertices = [('a', "A"), ('b', "B"), ('c', "C"),
                 ('d', "D"), ('e', "E"), ('f', "F"), ('g', "G"), ('h', "H"),
                 ('x', "X")]

localEdges = [('a', 'x', 'A0100', 30),
              ('f', 'a', 'A0100', 30), ('b', 'a', 'A0100', 40),
              ('b', 'c', 'A0100', 60),
              ('d', 'e', 'A0100', 100), ('e', 'x', 'A0100', 49),
              ('c', 'x', 'A0110', 21), ('x', 'h', 'A0100', 100),
              ('h', 'g', 'A0100', 100)]


class BeliefPropagation(object):

    @classmethod
    def runBPwithGraphFrames(cls, g, numIter):
        """Run Belief Propagation using GraphFrame.

        This implementation of BP shows how to use GraphFrame's aggregateMessages method.
        """
        # choose colors for vertices for scheduling
        colorG = cls._colorGraph(g)
        numColors = colorG.vertices.select('color').distinct().count()

        # TODO: handle vertices without any edges

        # initialize vertex beliefs at 0.0
        gx = GraphFrame(colorG.vertices.withColumn('belief', sqlfunctions.lit(0.0)), colorG.edges)

        # run BP for numIter iterations
        for iter_ in range(numIter):
            # for each color, have that color receive messages from neighbors
            for color in range(numColors):
                # Send messages to vertices of the current color.
                # We may send to source or destination since edges are treated as undirected.
                msgForSrc = sqlfunctions.when(
                    AM.src['color'] == color,
                    AM.edge['b'] * AM.dst['belief'])
                msgForDst = sqlfunctions.when(
                    AM.dst['color'] == color,
                    AM.edge['b'] * AM.src['belief'])
                # numerically stable sigmoid
                logistic = sqlfunctions.udf(cls._sigmoid, returnType=types.DoubleType())
                aggregates = gx.aggregateMessages(
                    sqlfunctions.sum(AM.msg).alias("aggMess"),
                    sendToSrc=msgForSrc,
                    sendToDst=msgForDst)
                v = gx.vertices
                # receive messages and update beliefs for vertices of the current color
                newBeliefCol = sqlfunctions.when(
                    (v['color'] == color) & (aggregates['aggMess'].isNotNull()),
                    logistic(aggregates['aggMess'] + v['a'])
                ).otherwise(v['belief'])  # keep old beliefs for other colors
                newVertices = (v
                    .join(aggregates, on=(v['id'] == aggregates['id']), how='left_outer')
                    .drop(aggregates['id'])  # drop duplicate ID column (from outer join)
                    .withColumn('newBelief', newBeliefCol)  # compute new beliefs
                    .drop('aggMess')  # drop messages
                    .drop('belief')  # drop old beliefs
                    .withColumnRenamed('newBelief', 'belief')
                )
                # cache new vertices using workaround for SPARK-1334
                cachedNewVertices = AM.getCachedDataFrame(newVertices)
                gx = GraphFrame(cachedNewVertices, gx.edges)

        # Drop the "color" column from vertices
        return GraphFrame(gx.vertices.drop('color'), gx.edges)

    @staticmethod
    def _colorGraph(g):
        """Given a GraphFrame, choose colors for each vertex.

        No neighboring vertices will share the same color. The number of colors is minimized.

        This is written specifically for grid graphs. For non-grid graphs, it should be generalized,
        such as by using a greedy coloring scheme.

        :param g: Grid graph generated by :meth:`Graphs.gridIsingModel()`
        :return: Same graph, but with a new vertex column "color" of type Int (0 or 1)

        """

        colorUDF = sqlfunctions.udf(lambda i, j: (i + j) % 2, returnType=types.IntegerType())
        v = g.vertices.withColumn('color', colorUDF(sqlfunctions.col('i'), sqlfunctions.col('j')))
        return GraphFrame(v, g.edges)

    @staticmethod
    def _sigmoid(x):
        """Numerically stable sigmoid function 1 / (1 + exp(-x))"""
        if not x:
            return None
        if x >= 0:
            z = math.exp(-x)
            return 1 / (1 + z)
        else:
            z = math.exp(x)
            return z / (1 + z)


def main():
    """Run the belief propagation algorithm for an example problem."""
    # setup context
    conf = SparkConf().setAppName("BeliefPropagation example")
    sc = SparkContext.getOrCreate(conf)
    # sql = SQLContext.getOrCreate(sc)

    # create graphical model g of size 3 x 3
    # g = graphframes.examples.Graphs(sql).gridIsingModel(3)
    # print("Original Ising model:")
    # g.vertices.show()
    # g.edges.show()
    nodes = sqlContext.createDataFrame(localVertices, ["id", "name"])
    edges = sqlContext.createDataFrame(localEdges, ["src", "dst", "edge_type", "ratio"])
    graph = GraphFrame(nodes, edges)
    print("Original model:")
    graph.vertices.show()
    graph.edges.show()

    # # run for 5 steps
    # numIter = 5
    # results = BeliefPropagation.runBPwithGraphFrames(graph, numIter)

    # # display beliefs
    # beliefs = results.vertices.select('id', 'name')
    # print("Done with BP. Final beliefs after {} iterations:".format(numIter))
    # beliefs.show()

    # sc.stop()

if __name__ == '__main__':
    main()
